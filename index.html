<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Resistance & Current Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #controls { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: center; }
    label { margin-right: 6px; }
    #plots { display: flex; flex-direction: column; gap: 40px; }
    .plot { width: 100%; height: 400px; }
    #status { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <h2>Resistance & Current Viewer</h2>

  <div id="controls">
    <!-- æ™®é€šæ¨¡å¼ -->
    <div>
      <input type="file" id="fileInput" accept=".csv,.txt" />
      <span style="font-size:12px;color:#666">ï¼ˆå¿«ç…§æ¨¡å¼ï¼‰</span>
    </div>

    <!-- å®æ—¶æ¨¡å¼ -->
    <div>
      <button id="liveBtn" onclick="pickLiveFile()">é€‰æ‹©å®æ—¶æ–‡ä»¶</button>
      <span style="font-size:12px;color:#666">ï¼ˆä»…Chrome/Edge/Chromiumï¼‰</span>
    </div>

    <div>
      <label>Show last (s):</label>
      <input type="number" id="windowSec" min="0" placeholder="all" style="width:90px" />
      <button onclick="drawPlots()">Update</button>
      <button onclick="reloadFile()">Refresh</button>
    </div>

    <div>
      <label>Auto refresh (s):</label>
      <input type="number" id="refreshSec" min="1" placeholder="e.g. 5" style="width:90px" />
      <button id="autoBtn" onclick="toggleAutoRefresh()">Start Auto</button>
      <span id="status"></span>
    </div>
  </div>

  <div id="plots">
    <div id="resPlot" class="plot"></div>
    <div id="curPlot" class="plot"></div>
  </div>

  <script>
    let rawData = [];
    let lastFile = null;      // <input> å¿«ç…§æ¨¡å¼æ–‡ä»¶
    let fileHandle = null;    // å®æ—¶æ¨¡å¼å¥æŸ„
    let refreshTimer = null;  // å®šæ—¶å™¨

    const statusEl = document.getElementById("status");
    const autoBtn  = document.getElementById("autoBtn");

    // ========== é€‰æ‹©æ–‡ä»¶ï¼ˆæ™®é€šæ¨¡å¼ï¼‰ ==========
    document.getElementById("fileInput").addEventListener("change", function (evt) {
      const file = evt.target.files[0];
      if (!file) return;
      fileHandle = null; // åˆ‡æ¢åˆ°å¿«ç…§æ¨¡å¼
      lastFile = file;
      parseFile(file);
      setStatus("ğŸ“‚ ä½¿ç”¨å¿«ç…§æ–‡ä»¶æ¨¡å¼");
    });

    // ========== é€‰æ‹©å®æ—¶æ–‡ä»¶ï¼ˆä»…Chrome/Edgeï¼‰ ==========
    async function pickLiveFile() {
      if (!window.showOpenFilePicker) {
        alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ File System Access APIï¼Œè¯·ä½¿ç”¨ Chrome/Edge/Chromiumã€‚");
        return;
      }
      try {
        [fileHandle] = await window.showOpenFilePicker({
          types: [{ description: "Text/CSV files", accept: { "text/plain": [".txt", ".csv"] } }]
        });
        lastFile = null; // åˆ‡æ¢åˆ°å®æ—¶æ¨¡å¼
        await reloadFile();
        setStatus("â±ï¸ ä½¿ç”¨å®æ—¶æ–‡ä»¶æ¨¡å¼");
      } catch (err) {
        console.error(err);
      }
    }

    // ========== çŠ¶æ€æ˜¾ç¤º ==========
    function setStatus(msg) {
      statusEl.textContent = msg || "";
    }

    // ========== æ‰‹åŠ¨åˆ·æ–° ==========
    async function reloadFile() {
      try {
        if (fileHandle) {
          // å®æ—¶æ¨¡å¼ï¼šæ¯æ¬¡ getFile() æ‹¿æœ€æ–°å†…å®¹
          const file = await fileHandle.getFile();
          parseFile(file);
        } else if (lastFile) {
          parseFile(lastFile);
        } else {
          alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶");
        }
      } catch (err) {
        console.error("åˆ·æ–°å¤±è´¥:", err);
      }
    }

    // ========== è‡ªåŠ¨åˆ·æ–° ==========
    function toggleAutoRefresh() {
      if (refreshTimer) {
        clearInterval(refreshTimer);
        refreshTimer = null;
        autoBtn.textContent = "Start Auto";
        setStatus("è‡ªåŠ¨åˆ·æ–°å·²åœæ­¢");
        return;
      }
      const sec = parseFloat(document.getElementById("refreshSec").value);
      if (isNaN(sec) || sec <= 0) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰");
        return;
      }
      reloadFile();
      refreshTimer = setInterval(reloadFile, sec * 1000);
      autoBtn.textContent = "Stop Auto";
      setStatus(`å·²å¼€å¯è‡ªåŠ¨åˆ·æ–°ï¼šæ¯ ${sec} ç§’æ›´æ–°ä¸€æ¬¡`);
    }

    // ========== è§£ææ–‡ä»¶ ==========
    function parseFile(file) {
      Papa.parse(file, {
        delimiter: " ",
        skipEmptyLines: true,
        complete: function (results) {
          rawData = results.data.map(row => {
            row = row.filter(v => String(v).trim() !== "");
            return {
              time: parseFloat(row[0]),
              current: parseFloat(row[1]),
              resistance: parseFloat(row[2]),
              sw: parseFloat(row[3]) > 0.5 ? 1 : 0
            };
          }).filter(r => !isNaN(r.time));

          setStatus(`è½½å…¥ ${rawData.length} è¡Œæ•°æ®ï¼ˆ${new Date().toLocaleTimeString()}ï¼‰`);
          drawPlots();
        }
      });
    }

    // ========== ç»˜å›¾ ==========
    function drawPlots() {
      if (rawData.length === 0) return;

      let windowSec = parseFloat(document.getElementById("windowSec").value);
      if (isNaN(windowSec) || windowSec <= 0) windowSec = null;

      let data = rawData;
      if (windowSec) {
        const tmax = data[data.length - 1].time;
        data = data.filter(d => d.time >= tmax - windowSec);
      }

      const t  = data.map(d => d.time);
      const r  = data.map(d => d.resistance);
      const i  = data.map(d => d.current);
      const sw = data.map(d => d.sw);

      const resTraces = [{ x: t, y: r, mode: "lines", name: "Resistance (Ohm)", line: { color: "blue" } }];
      const curTraces = [{ x: t, y: i, mode: "lines", name: "Current (A)",    line: { color: "red"  } }];

      let shapesRes = [], shapesCur = [];
      let inBlock = false, start = null;
      for (let j = 0; j < sw.length; j++) {
        if (sw[j] === 1 && !inBlock) {
          inBlock = true; start = t[j];
        } else if (sw[j] === 0 && inBlock) {
          inBlock = false;
          shapesRes.push({ type: "rect", xref: "x", yref: "paper", x0: start, x1: t[j], y0: 0, y1: 1, fillcolor: "grey", opacity: 0.2, line: { width: 0 } });
          shapesCur.push({ type: "rect", xref: "x", yref: "paper", x0: start, x1: t[j], y0: 0, y1: 1, fillcolor: "grey", opacity: 0.2, line: { width: 0 } });
        }
      }
      if (inBlock && t.length > 0) {
        const end = t[t.length - 1];
        shapesRes.push({ type: "rect", xref: "x", yref: "paper", x0: start, x1: end, y0: 0, y1: 1, fillcolor: "grey", opacity: 0.2, line: { width: 0 } });
        shapesCur.push({ type: "rect", xref: "x", yref: "paper", x0: start, x1: end, y0: 0, y1: 1, fillcolor: "grey", opacity: 0.2, line: { width: 0 } });
      }

      Plotly.newPlot("resPlot", resTraces, {
        title: "Resistance vs Time",
        xaxis: { title: "Time (s)" },
        yaxis: { title: "Resistance (Ohm)" },
        shapes: shapesRes
      });

      Plotly.newPlot("curPlot", curTraces, {
        title: "Current vs Time",
        xaxis: { title: "Time (s)" },
        yaxis: { title: "Current (A)" },
        shapes: shapesCur
      });
    }

    // é¡µé¢å…³é—­æ—¶æ¸…æ‰å®šæ—¶å™¨
    window.addEventListener("beforeunload", () => {
      if (refreshTimer) clearInterval(refreshTimer);
    });
  </script>
</body>
</html>
